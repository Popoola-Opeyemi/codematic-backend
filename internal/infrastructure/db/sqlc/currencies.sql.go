// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: currencies.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createCurrency = `-- name: CreateCurrency :one
INSERT INTO currencies (code, name, symbol)
VALUES ($1, $2, $3)
RETURNING code, name, symbol, is_active, created_at, updated_at
`

type CreateCurrencyParams struct {
	Code   string
	Name   string
	Symbol string
}

func (q *Queries) CreateCurrency(ctx context.Context, arg CreateCurrencyParams) (Currency, error) {
	row := q.db.QueryRow(ctx, createCurrency, arg.Code, arg.Name, arg.Symbol)
	var i Currency
	err := row.Scan(
		&i.Code,
		&i.Name,
		&i.Symbol,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const currencyExists = `-- name: CurrencyExists :one
SELECT EXISTS (
  SELECT 1 FROM currencies WHERE code = $1 AND is_active = true
)
`

func (q *Queries) CurrencyExists(ctx context.Context, code string) (bool, error) {
	row := q.db.QueryRow(ctx, currencyExists, code)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const deactivateCurrency = `-- name: DeactivateCurrency :exec
UPDATE currencies 
SET is_active = false, updated_at = now()
WHERE code = $1
`

func (q *Queries) DeactivateCurrency(ctx context.Context, code string) error {
	_, err := q.db.Exec(ctx, deactivateCurrency, code)
	return err
}

const getCurrencyByCode = `-- name: GetCurrencyByCode :one
SELECT code, name, symbol, is_active, created_at, updated_at FROM currencies WHERE code = $1
`

func (q *Queries) GetCurrencyByCode(ctx context.Context, code string) (Currency, error) {
	row := q.db.QueryRow(ctx, getCurrencyByCode, code)
	var i Currency
	err := row.Scan(
		&i.Code,
		&i.Name,
		&i.Symbol,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listActiveCurrencies = `-- name: ListActiveCurrencies :many
SELECT code, name, symbol, is_active, created_at, updated_at FROM currencies WHERE is_active = true ORDER BY code ASC
`

func (q *Queries) ListActiveCurrencies(ctx context.Context) ([]Currency, error) {
	rows, err := q.db.Query(ctx, listActiveCurrencies)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Currency
	for rows.Next() {
		var i Currency
		if err := rows.Scan(
			&i.Code,
			&i.Name,
			&i.Symbol,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCurrency = `-- name: UpdateCurrency :exec
UPDATE currencies 
SET name = $1, symbol = $2, is_active = $3, updated_at = now()
WHERE code = $4
`

type UpdateCurrencyParams struct {
	Name     string
	Symbol   string
	IsActive pgtype.Bool
	Code     string
}

func (q *Queries) UpdateCurrency(ctx context.Context, arg UpdateCurrencyParams) error {
	_, err := q.db.Exec(ctx, updateCurrency,
		arg.Name,
		arg.Symbol,
		arg.IsActive,
		arg.Code,
	)
	return err
}
