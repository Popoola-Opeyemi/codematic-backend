// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: wallets.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
	"github.com/shopspring/decimal"
)

const createWallet = `-- name: CreateWallet :one
INSERT INTO wallets (id, user_id, wallet_type_id, balance)
VALUES ($1, $2, $3, $4)
RETURNING id, user_id, wallet_type_id, balance, status, created_at, updated_at
`

type CreateWalletParams struct {
	ID           pgtype.UUID
	UserID       pgtype.UUID
	WalletTypeID pgtype.UUID
	Balance      decimal.Decimal
}

func (q *Queries) CreateWallet(ctx context.Context, arg CreateWalletParams) (Wallet, error) {
	row := q.db.QueryRow(ctx, createWallet,
		arg.ID,
		arg.UserID,
		arg.WalletTypeID,
		arg.Balance,
	)
	var i Wallet
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.WalletTypeID,
		&i.Balance,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createWalletWithCurrency = `-- name: CreateWalletWithCurrency :one
INSERT INTO wallets (id, user_id, wallet_type_id, balance, status)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, user_id, wallet_type_id, balance, status, created_at, updated_at
`

type CreateWalletWithCurrencyParams struct {
	ID           pgtype.UUID
	UserID       pgtype.UUID
	WalletTypeID pgtype.UUID
	Balance      decimal.Decimal
	Status       string
}

func (q *Queries) CreateWalletWithCurrency(ctx context.Context, arg CreateWalletWithCurrencyParams) (Wallet, error) {
	row := q.db.QueryRow(ctx, createWalletWithCurrency,
		arg.ID,
		arg.UserID,
		arg.WalletTypeID,
		arg.Balance,
		arg.Status,
	)
	var i Wallet
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.WalletTypeID,
		&i.Balance,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const decrementWalletBalance = `-- name: DecrementWalletBalance :exec
UPDATE wallets SET balance = balance - $1, updated_at = now() WHERE id = $2
`

type DecrementWalletBalanceParams struct {
	Balance decimal.Decimal
	ID      pgtype.UUID
}

func (q *Queries) DecrementWalletBalance(ctx context.Context, arg DecrementWalletBalanceParams) error {
	_, err := q.db.Exec(ctx, decrementWalletBalance, arg.Balance, arg.ID)
	return err
}

const deleteWallet = `-- name: DeleteWallet :exec
DELETE FROM wallets WHERE id = $1
`

func (q *Queries) DeleteWallet(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteWallet, id)
	return err
}

const getWalletByID = `-- name: GetWalletByID :one
SELECT id, user_id, wallet_type_id, balance, status, created_at, updated_at FROM wallets WHERE id = $1
`

func (q *Queries) GetWalletByID(ctx context.Context, id pgtype.UUID) (Wallet, error) {
	row := q.db.QueryRow(ctx, getWalletByID, id)
	var i Wallet
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.WalletTypeID,
		&i.Balance,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getWalletByUserAndCurrency = `-- name: GetWalletByUserAndCurrency :one
SELECT w.id, w.user_id, w.wallet_type_id, w.balance, w.status, w.created_at, w.updated_at
FROM wallets w
JOIN wallet_types wt ON w.wallet_type_id = wt.id
WHERE w.user_id = $1 AND wt.currency = $2
LIMIT 1
`

type GetWalletByUserAndCurrencyParams struct {
	UserID   pgtype.UUID
	Currency string
}

func (q *Queries) GetWalletByUserAndCurrency(ctx context.Context, arg GetWalletByUserAndCurrencyParams) (Wallet, error) {
	row := q.db.QueryRow(ctx, getWalletByUserAndCurrency, arg.UserID, arg.Currency)
	var i Wallet
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.WalletTypeID,
		&i.Balance,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getWalletTypeIDByCurrency = `-- name: GetWalletTypeIDByCurrency :one
SELECT id
FROM wallet_types
WHERE currency = $1
LIMIT 1
`

func (q *Queries) GetWalletTypeIDByCurrency(ctx context.Context, currency string) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, getWalletTypeIDByCurrency, currency)
	var id pgtype.UUID
	err := row.Scan(&id)
	return id, err
}

const incrementWalletBalance = `-- name: IncrementWalletBalance :exec
UPDATE wallets SET balance = balance + $1, updated_at = now() WHERE id = $2
`

type IncrementWalletBalanceParams struct {
	Balance decimal.Decimal
	ID      pgtype.UUID
}

func (q *Queries) IncrementWalletBalance(ctx context.Context, arg IncrementWalletBalanceParams) error {
	_, err := q.db.Exec(ctx, incrementWalletBalance, arg.Balance, arg.ID)
	return err
}

const listActiveWalletTypes = `-- name: ListActiveWalletTypes :many
SELECT id, name, currency, is_active, description, created_at, updated_at FROM wallet_types WHERE is_active ORDER BY currency ASC
`

func (q *Queries) ListActiveWalletTypes(ctx context.Context) ([]WalletType, error) {
	rows, err := q.db.Query(ctx, listActiveWalletTypes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WalletType
	for rows.Next() {
		var i WalletType
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Currency,
			&i.IsActive,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWalletsByCurrency = `-- name: ListWalletsByCurrency :many
SELECT w.id, w.user_id, w.wallet_type_id, w.balance, w.status, w.created_at, w.updated_at
FROM wallets w
JOIN wallet_types wt ON w.wallet_type_id = wt.id
WHERE wt.currency = $1
ORDER BY w.created_at DESC
`

func (q *Queries) ListWalletsByCurrency(ctx context.Context, currency string) ([]Wallet, error) {
	rows, err := q.db.Query(ctx, listWalletsByCurrency, currency)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Wallet
	for rows.Next() {
		var i Wallet
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.WalletTypeID,
			&i.Balance,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWalletsByType = `-- name: ListWalletsByType :many
SELECT id, user_id, wallet_type_id, balance, status, created_at, updated_at FROM wallets WHERE wallet_type_id = $1 ORDER BY created_at DESC
`

func (q *Queries) ListWalletsByType(ctx context.Context, walletTypeID pgtype.UUID) ([]Wallet, error) {
	rows, err := q.db.Query(ctx, listWalletsByType, walletTypeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Wallet
	for rows.Next() {
		var i Wallet
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.WalletTypeID,
			&i.Balance,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWalletsByUserAndCurrency = `-- name: ListWalletsByUserAndCurrency :many
SELECT w.id, w.user_id, w.wallet_type_id, w.balance, w.status, w.created_at, w.updated_at
FROM wallets w
JOIN wallet_types wt ON w.wallet_type_id = wt.id
WHERE w.user_id = $1 AND wt.currency = $2
ORDER BY w.created_at DESC
`

type ListWalletsByUserAndCurrencyParams struct {
	UserID   pgtype.UUID
	Currency string
}

func (q *Queries) ListWalletsByUserAndCurrency(ctx context.Context, arg ListWalletsByUserAndCurrencyParams) ([]Wallet, error) {
	rows, err := q.db.Query(ctx, listWalletsByUserAndCurrency, arg.UserID, arg.Currency)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Wallet
	for rows.Next() {
		var i Wallet
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.WalletTypeID,
			&i.Balance,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWalletsByUserID = `-- name: ListWalletsByUserID :many
SELECT id, user_id, wallet_type_id, balance, status, created_at, updated_at FROM wallets WHERE user_id = $1 ORDER BY created_at DESC
`

func (q *Queries) ListWalletsByUserID(ctx context.Context, userID pgtype.UUID) ([]Wallet, error) {
	rows, err := q.db.Query(ctx, listWalletsByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Wallet
	for rows.Next() {
		var i Wallet
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.WalletTypeID,
			&i.Balance,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateWalletBalance = `-- name: UpdateWalletBalance :exec
UPDATE wallets SET balance = $1, updated_at = now() WHERE id = $2
`

type UpdateWalletBalanceParams struct {
	Balance decimal.Decimal
	ID      pgtype.UUID
}

func (q *Queries) UpdateWalletBalance(ctx context.Context, arg UpdateWalletBalanceParams) error {
	_, err := q.db.Exec(ctx, updateWalletBalance, arg.Balance, arg.ID)
	return err
}

const updateWalletType = `-- name: UpdateWalletType :exec
UPDATE wallets SET wallet_type_id = $1, updated_at = now() WHERE id = $2
`

type UpdateWalletTypeParams struct {
	WalletTypeID pgtype.UUID
	ID           pgtype.UUID
}

func (q *Queries) UpdateWalletType(ctx context.Context, arg UpdateWalletTypeParams) error {
	_, err := q.db.Exec(ctx, updateWalletType, arg.WalletTypeID, arg.ID)
	return err
}
